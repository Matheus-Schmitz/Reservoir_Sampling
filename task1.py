'''
DSCI 553 | Foundations and Applications of Data Mining
Homework 5
Matheus Schmitz
'''

from blackbox import BlackBox
import sys
import binascii
import random
import time


# Generate parameters for the hash functions
hash_params = [[random.randint(1, 100), random.randint(1, 100)] for _ in range(10)]

# Initialize the filter bit array
filter_bit_array = [0 for _ in range(69997)]
m = len(filter_bit_array)


def myhashs(user):

    # Encode user to int
    user_int = int(binascii.hexlify(user.encode('utf8')),16)

    # Generate hash values
    result = []
    for f in hash_params:
        result.append((f[0] * user_int + f[1]) % m)
    
    return result


if __name__ == "__main__":

	#start_time = time.time()

	# Read user inputs
	input_filename = sys.argv[1]
	stream_size = int(sys.argv[2])	
	num_of_asks = int(sys.argv[3])
	output_filename = sys.argv[4]

	# Variables to track performance
	seen_users_truth = set()
	seen_users_preds = set()

	# Before beginning to iterate, write the column headers
	with open(output_filename, "w") as f_out:
		f_out.write("Time,FPR")

	# Blackbox
	BB = BlackBox()

	# Iterate over the asks
	for ask_iteration in range(num_of_asks):
		stream_users = BB.ask(input_filename, stream_size)

		# According to Piazza post 502 FP and TN should be reset between iterations
		FP = 0.0
		TN = 0.0
		
		# Go over all users for this stream
		for user in stream_users:

			# List to store all indexes generated by all hashes * users for this iteration, so the bit array can be updated when the iteration ends
			stream_hashed_idxs = []

			# If I have actually seen the user before, then I should not test the match, as surely it will match because it should
			# In this case it would be a true positive, which I'm not interested in
			if user in seen_users_truth:
				continue

			# Hash the user into values
			hashed_idxs = myhashs(user)

			# Track how many of the hashed indexes colide with pre-existing 1s on the filter_bit_array
			bit_matches = 0
			for idx in hashed_idxs:
				if filter_bit_array[idx] == 1:
					bit_matches += 1

			# If all bits matches, then we have a false positive, else a true negative
			if bit_matches == len(hashed_idxs):

				# Make a prediction that already seen the users
				seen_users_preds.add(user)
				
				# Since the truly seen users have been weed out before, I know this is a false positive
				FP += 1

			else:
				TN += 1

			# Add the current user hashed indexes to the list with all indexes from the iteration, so that when the iteration finishes the bit array can be updated		
			stream_hashed_idxs.append(hashed_idxs)

		# Update the Bloom Filter after the iteration is done
		for user_hashed_idxs in stream_hashed_idxs:
			for idx in user_hashed_idxs:
				filter_bit_array[idx] = 1

		# Update the ground truth after the iteration is done
		seen_users_truth.update(stream_users)				

		# Once all users of the current stream have been iterated through, calculate the iteration's FPR
		FPR = float(FP) / (float(FP) + float(TN))

		# Then append the results to the output file
		with open(output_filename, "a") as f_out:
			f_out.write("\n" + str(ask_iteration) + "," + str(FPR))

	# Measure the total time taken and report it
	#time_elapsed = time.time() - start_time
	#print('Duration: {}'.format(time_elapsed))